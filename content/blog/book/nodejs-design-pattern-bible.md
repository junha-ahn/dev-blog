---
title: <Node.js 디자인패턴 바이블> 후기
date: "2021-07-17T06:56:33.577Z"
description: "Node.js 개발자라면 꼭 읽어보세요!"
category: book
draft: false
---

Node.js에 관련된 여러 디자인 패턴을 정리 해놓은 좋은 책입니다. 

**Node.js 개발자라면 꼭 읽어보세요! 추천합니다**

[구매 링크](http://www.yes24.com/Product/Goods/101686866)

각 챕터에 어떤 내용이 있는지, 어떤 부분이 인상 깊었는지 소개하겠습니다

## Chapter 01 Node.js 플랫폼

Node.js가 어떤 언어인지 소개합니다. 

V8, libuv, 이벤트루프 등을 간략하게 소개합니다.

## Chapter 02 모듈 시스템

CommonJs, ESM(ECMAScript 모듈)를 소개하고 차이점등을 알려줍니다.
- 그리고 모듈 캐시(동일한 모듈은 얼마간 동일한 인스턴스가 반환됨을 보장), 순환 종속성, 비동기 임포트등의 내용이 포함됬습니다.

깨닫지 못했지만 자바스크립트에는 오랫동안 모듈 시스템이 없었습니다.
- `<script>` 태그를 통해 간단하게 임포트 하였을 뿐입니다. 
- 지금까진 모듈 시스템 없이 별 문제가 없었습니다.

특히 '**모듈 캐시**', '**순환종속성**' 부분이 특히 좋았습니다. (지금까지는 그냥 사용하던...)

## Chapter 03 콜백과 이벤트

비동기적 코드의 작성을 콜백 패턴과 관찰자 패턴을 통해 소개합니다.

`Node.js`로 개발하는 저로썬 `Event`를 기반으로 한 관찰자 패턴은 사용할 일이 크게...? (물런 콜백 패턴도 `Promise`로 대체합니다)

## Chapter 04 콜백을 사용한 비동기 제어 흐름 패턴

콜백 지옥, 모범적인 콜백 패턴, 순차 실행과 병렬 실행, 제한된 병렬 실행 등을 소개합니다.
- 병렬 실행은 이벤트 루프를 이용한 자바스크립트적인 병렬실행을 의미합니다. 

## Chapter 05 Promise 그리고 Async/Await와 함께 하는 비동기 제어 흐름 패턴

챕터명이 모든걸 설명합니다!
- 제한된 병렬 실행(`Queue`)을 다루다 생산자, 소비자 문제를 언급하며 
- `Array.forEach()`를 사용할때 `Asyc/Await` 사용을 주의해야하는 부분
- `return` 과 `return await` 의 차이점등 실무에서 유용한 내용도 포함되어 있습니다.

## Chapter 06 스트림 코딩

스트림과 버퍼의 차이, 그리고 Node.js 스트림 코딩에 대해서 상세히 설명합니다.

Node.js 스트림 코딩이 이렇게 다룰 내용이 많은지 전혀 몰랐습니다...

## Chapter 07 생성자 디자인 패턴

말그래도 생성에 관련된 디자인디자인패턴을 소개합니다.
- 팩토리, 빌더, 공개 생성자, 싱글통, 모듈 와이어링, DI(종속성 주입)

빌더 패턴의 경우 많은 모듈이 사용하고 있는데, 재밌게 읽었습니다.

```javascript
const url = new UrlBuilder()
  .setProtocol('https')
  .setHostname('example.com')
  .build()

console.log(url.toString()) // https://example.com
```

공개 생성자 패턴은 생성시에만 동작을 정의하며 수정이 불가능한 객체를 생성합니다.
- 가장 대표적인 사례는 Promise입니다.

```javascript
return new Promise((resolve, reject) => {
  // ...
})
```

### 모듈 와이어링

모든 애플리케이션은 여러 컴퍼넌트를 연결한 결과입니다
- 또한 규모가 커짐에 따라 연결 하는 방식은 성공 및 유지보수에 매우 중요해집니다.

두개의 컴퍼넌트 사이의 **종속성**이 존재하며, 이를 연결하는 방법 두 가지를 소개합니다
- **싱글톤 방식과, DI** 입니다.

저 개인적으로는 **DI 방식 (+ 인젝터)**을 좋아합니다

## Chapter 08 구조적 설계 패턴

엔티티 간의 **관계를 다루는 기술**을 소개합니다

- 프록시: 다른 객체에 대한 엑세스를 제어할 수 있는 패턴 (그리고 내장 프록시 객체)
- 데코레이터: 기존 객체의 동작을 동적으로 증강시키는 패턴
- 어댑터: 다른 인터페이스를 사용해 객체의 기능을 엑세스 할 수 있는 패턴

특히 변경을 감지하는 옵저버를 소개했는데, 이 부분이 매우 흥미로웠습니다
- 지금까지 Vue.js, React.js에서 객체의 변경을 어떻게 감지하는지 몰랐었는데, 읽으면서 굉장히 새로웠습니다.

참고로 **프록시와 데코레이터의 차이점**을 명확히 정리해주는데 이렇습니다

> 데코레이터 패턴은 래퍼로 볼 수 있다. 다양한 객체를 가져와 데코레이터로 감싸 '추가적인 기능'을 추가 할 수 있다. 
> 프록시는 대신 객체에 대한 접근을 제어하는데 사용되며 원래의 인터페이스를 변경하지 않는다.


## Chapter 09 행위 디자인 패턴

객체를 어떻게 확장가능하고, 모듈화되고, 재사용가능하게 결합하는 방법과 상호작용 하는 방법에 대해 소개합니다.

특히 이 장에서 소개되는 패턴 중 일부는 몰랐지만 비슷하게 구현을 생각해내어 사용해 본적이 있다는게 재밌었습니다.

- 특정 요구사항에 맞게 컴포넌트의 일부를 변경하는데 도움이 되는 전략(Strategy) 패턴
- 상태(State) 패턴: 상태에 따라 컴포넌트의 동작을 변경시킬 수 있습니다.
- 새로운 것을 정의하기 위해 컴포넌트의 구조를 재사용할 수 있는 템플릿(Template) 패턴
- 컬렉션을 반복하기 위한 공통의 인터페이스를 제공하는 반복자(Iterator) 패턴
- 미들웨어(Middleware) 패턴: 모듈식 처리 절차를 정의할 수 있는 패턴
- 커맨드(Command) 패턴: 루틴 실행에 필요한 정보를 구체화하여 쉽게 전송, 저장 및 처리할 수 있는 패턴

> 개발을 할때 이러한 패턴을 고려하면서, 장단점을 생각하고 선택해서 객체를 디자인하는 그런 개발 해보고 싶네요. 물런 당장은 Nest.js 같은 프레임워크를 이용하는걸로 하겠습니다

## Chapter 10 웹 애플리케이션을 위한 범용 Javascript

브라우저 코드 공유, 크로스 플랫폼 개발의 기초, React 등을 소개합니다.
- 모듈 번들러 런타임(Node.js, 웹브라우저) 코드 분기, 관련 디자인 패턴 등을 소개합니다.

## Chapter 11 고급 레시피

비동기적으로 초기화되는 컴포넌트 다루기
- 특히 db 객체의 connection 등

비동기식 요청 일괄 처리 및 캐싱, 비동기 작업 취소

CPU 바운드 작업 실행
- 완료할때까지 오래걸리며, 이벤트 루프에 제어권을 돌려주지 않는 작업을 CPU 바인딩이라고 한다.
- 이러한 CPU 바인딩 작업을 효율적으로 실행하는 방법에 대해 소개한다. (`setImmediate`, `child proceess`, `worker threads` 등)


## Chapter 12 확장성과 아키텍처 패턴

애플리케이션 확장에 대해 소개한다. 간단히 말해 **배포**에 관련된 부분이다.

물리서버 복제를 통한 확장, 로드밸런싱, 클러스터 모듈 그리고 Nginx, docker, k9s 등 다양한 방법을 소개한다.

모놀리식 아키텍처, 마이크로 서비스 아키텍처와 설계시 주의점도 언급된다.

## Chapter 13 메시징 통합 패턴

연결(통신)에 대해 소개하며, Publish/Subscripbe, 작업 배포(Task distribution) 패턴 등등을 소개한다

또한 `ZeroMQ` 모듈의 사용법 등을 소개하며 상세히 다룬다.